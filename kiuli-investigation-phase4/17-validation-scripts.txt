=== ALL VALIDATION SCRIPTS ===

========================================
=== FILE: validation_scripts/validate_phase_0.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 0: Environment & Prerequisite Validation
 * This script validates all required environment variables and dependencies
 * before proceeding with the Kiuli Scraper build.
 */

// Load environment variables from .env.local
require('dotenv').config({ path: '.env.local' });

const { execSync } = require('child_process');
const https = require('https');
const http = require('http');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
};

// Track validation results
const results = {
  passed: [],
  failed: [],
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Helper function to execute shell commands
function executeCommand(command) {
  try {
    return execSync(command, { encoding: 'utf8', stdio: 'pipe' });
  } catch (error) {
    return null;
  }
}

// Helper function to fetch from URL
function fetchUrl(url, headers = {}) {
  return new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;
    const urlObj = new URL(url);

    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port,
      path: urlObj.pathname + urlObj.search,
      method: 'GET',
      headers: headers,
    };

    const req = protocol.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => data += chunk);
      res.on('end', () => resolve({ statusCode: res.statusCode, data }));
    });

    req.on('error', reject);
    req.setTimeout(20000, () => {
      req.destroy();
      reject(new Error('Request timeout'));
    });
    req.end();
  });
}

// Check 1: Node.js Version
async function checkNodeVersion() {
  log('\n[1/5] Checking Node.js version...', colors.blue);

  try {
    const version = process.version;
    const majorVersion = parseInt(version.slice(1).split('.')[0]);

    if (majorVersion >= 18) {
      log(`  ✓ Node.js version: ${version} (>= 18.x)`, colors.green);
      results.passed.push('Node.js Version');
      return true;
    } else {
      log(`  ✗ Node.js version: ${version} (requires >= 18.x)`, colors.red);
      results.failed.push('Node.js Version');
      return false;
    }
  } catch (error) {
    log(`  ✗ Failed to check Node.js version: ${error.message}`, colors.red);
    results.failed.push('Node.js Version');
    return false;
  }
}

// Check 2: Vercel CLI
async function checkVercelCLI() {
  log('\n[2/5] Checking Vercel CLI...', colors.blue);

  try {
    const output = executeCommand('vercel --version');

    if (output) {
      log(`  ✓ Vercel CLI installed: ${output.trim()}`, colors.green);
      results.passed.push('Vercel CLI');
      return true;
    } else {
      log('  ✗ Vercel CLI not found or failed to execute', colors.red);
      results.failed.push('Vercel CLI');
      return false;
    }
  } catch (error) {
    log(`  ✗ Vercel CLI check failed: ${error.message}`, colors.red);
    results.failed.push('Vercel CLI');
    return false;
  }
}

// Check 3: Payload CMS API
async function checkPayloadAPI() {
  log('\n[3/5] Checking Payload CMS API...', colors.blue);

  try {
    // Check environment variables
    const apiUrl = process.env.PAYLOAD_API_URL;
    const apiKey = process.env.PAYLOAD_API_KEY;

    if (!apiUrl) {
      log('  ✗ PAYLOAD_API_URL environment variable not set', colors.red);
      results.failed.push('Payload CMS API');
      return false;
    }

    if (!apiKey) {
      log('  ✗ PAYLOAD_API_KEY environment variable not set', colors.red);
      results.failed.push('Payload CMS API');
      return false;
    }

    log(`  ✓ PAYLOAD_API_URL: ${apiUrl}`, colors.green);
    log(`  ✓ PAYLOAD_API_KEY: ${apiKey.substring(0, 8)}...`, colors.green);

    // Attempt authenticated request
    log('  → Testing API connection...', colors.yellow);

    const testUrl = `${apiUrl}/api/users/me`;
    const response = await fetchUrl(testUrl, {
      'Authorization': `users API-Key ${apiKey}`,
      'Content-Type': 'application/json',
    });

    if (response.statusCode === 200 || response.statusCode === 201) {
      log(`  ✓ Payload API responded with status ${response.statusCode}`, colors.green);
      results.passed.push('Payload CMS API');
      return true;
    } else {
      log(`  ✗ Payload API responded with unexpected status ${response.statusCode}`, colors.red);
      results.failed.push('Payload CMS API');
      return false;
    }
  } catch (error) {
    log(`  ✗ Payload API check failed: ${error.message}`, colors.red);
    results.failed.push('Payload CMS API');
    return false;
  }
}

// Check 4: Gemini AI API
async function checkGeminiAPI() {
  log('\n[4/5] Checking Gemini AI API...', colors.blue);

  try {
    const apiKey = process.env.GEMINI_API_KEY;

    if (!apiKey) {
      log('  ✗ GEMINI_API_KEY environment variable not set', colors.red);
      results.failed.push('Gemini AI API');
      return false;
    }

    log(`  ✓ GEMINI_API_KEY: ${apiKey.substring(0, 8)}...`, colors.green);
    results.passed.push('Gemini AI API');
    return true;
  } catch (error) {
    log(`  ✗ Gemini API check failed: ${error.message}`, colors.red);
    results.failed.push('Gemini AI API');
    return false;
  }
}

// Check 5: Google Service Account
async function checkGoogleServiceAccount() {
  log('\n[5/5] Checking Google Service Account...', colors.blue);

  try {
    const jsonPath = process.env.GOOGLE_SERVICE_ACCOUNT_JSON_PATH;

    if (!jsonPath) {
      log('  ✗ GOOGLE_SERVICE_ACCOUNT_JSON_PATH environment variable not set', colors.red);
      log('  ℹ Note: This check is expected to fail in Phase 0 (Human Gate)', colors.yellow);
      results.failed.push('Google Service Account');
      return false;
    }

    log(`  ✓ GOOGLE_SERVICE_ACCOUNT_JSON_PATH: ${jsonPath}`, colors.green);
    results.passed.push('Google Service Account');
    return true;
  } catch (error) {
    log(`  ✗ Google Service Account check failed: ${error.message}`, colors.red);
    results.failed.push('Google Service Account');
    return false;
  }
}

// Main validation function
async function runValidation() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 0: ENVIRONMENT & PREREQUISITE VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  const checks = [
    checkNodeVersion,
    checkVercelCLI,
    checkPayloadAPI,
    checkGeminiAPI,
    checkGoogleServiceAccount,
  ];

  for (const check of checks) {
    await check();
  }

  // Print summary
  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  if (results.passed.length > 0) {
    log(`\n✓ PASSED (${results.passed.length}):`, colors.green);
    results.passed.forEach(check => log(`  • ${check}`, colors.green));
  }

  if (results.failed.length > 0) {
    log(`\n✗ FAILED (${results.failed.length}):`, colors.red);
    results.failed.forEach(check => log(`  • ${check}`, colors.red));
  }

  // Determine if we can proceed to Phase 2
  const criticalChecks = ['Node.js Version', 'Vercel CLI', 'Payload CMS API', 'Gemini AI API'];
  const criticalFailures = results.failed.filter(check => criticalChecks.includes(check));

  log('\n' + '='.repeat(60), colors.bright);

  if (criticalFailures.length === 0) {
    log('  ✓ VALIDATION PASSED', colors.green);
    log('  Ready to proceed to Phase 2', colors.green);
    log('='.repeat(60) + '\n', colors.bright);
    process.exit(0);
  } else {
    log('  ✗ VALIDATION FAILED', colors.red);
    log('  Cannot proceed to Phase 2', colors.red);
    log(`  Critical failures: ${criticalFailures.join(', ')}`, colors.red);
    log('='.repeat(60) + '\n', colors.bright);
    process.exit(1);
  }
}

// Run the validation
runValidation().catch(error => {
  log(`\nFatal error: ${error.message}`, colors.red);
  process.exit(1);
});

========================================
=== FILE: validation_scripts/validate_phase_2.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 2: Scraper Foundation & API Interception - Validation Script
 *
 * This script validates the iTrvl scraper functionality by:
 * 1. Executing the scraper with a test URL
 * 2. Validating the output file structure and content
 * 3. Asserting all required data fields are present
 *
 * Usage: node validation_scripts/validate_phase_2.cjs --url <ITRVL_URL>
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  let url = null;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--url' && args[i + 1]) {
      url = args[i + 1];
      break;
    }
  }

  return { url };
}

// Delete the output file if it exists
function cleanupOutputFile(outputPath) {
  if (fs.existsSync(outputPath)) {
    fs.unlinkSync(outputPath);
    log(`  → Deleted corrupt output file: ${outputPath}`, colors.yellow);
  }
}

// Main validation function
async function validatePhase2(testUrl) {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 2: SCRAPER VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  const outputPath = path.join(process.cwd(), 'output', 'raw-itinerary.json');
  const scraperPath = path.join(process.cwd(), 'scrapers', 'itrvl_scraper.cjs');

  // Clean up any existing output file before starting
  if (fs.existsSync(outputPath)) {
    log('\n→ Cleaning up previous output file...', colors.yellow);
    fs.unlinkSync(outputPath);
  }

  // Step 1: Execute the scraper
  log('\n[1/5] Executing iTrvl scraper...', colors.blue);
  log(`  → URL: ${testUrl}`, colors.cyan);

  try {
    execSync(`node "${scraperPath}" "${testUrl}"`, {
      encoding: 'utf8',
      stdio: 'inherit',
      timeout: 120000, // 2 minute timeout
    });
    log('  ✓ Scraper executed successfully', colors.green);
  } catch (error) {
    log(`  ✗ Scraper execution failed: ${error.message}`, colors.red);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: Scraper script execution error', colors.red);
    process.exit(1);
  }

  // Step 2: Check that output file exists
  log('\n[2/5] Checking output file...', colors.blue);

  if (!fs.existsSync(outputPath)) {
    log(`  ✗ Output file not found: ${outputPath}`, colors.red);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: Output file was not created', colors.red);
    process.exit(1);
  }

  log(`  ✓ Output file exists: ${outputPath}`, colors.green);

  // Step 3: Check that output file is not empty
  const fileStats = fs.statSync(outputPath);
  const fileSizeKB = (fileStats.size / 1024).toFixed(2);

  if (fileStats.size === 0) {
    log('  ✗ Output file is empty', colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: Output file is empty', colors.red);
    process.exit(1);
  }

  log(`  ✓ Output file is not empty (${fileSizeKB} KB)`, colors.green);

  // Step 4: Parse the file as JSON
  log('\n[3/5] Parsing JSON...', colors.blue);
  let jsonData;

  try {
    const fileContent = fs.readFileSync(outputPath, 'utf8');
    jsonData = JSON.parse(fileContent);
    log('  ✓ Valid JSON format', colors.green);
  } catch (error) {
    log(`  ✗ Failed to parse JSON: ${error.message}`, colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: Invalid JSON format', colors.red);
    process.exit(1);
  }

  // Step 5: Assert expected structure
  log('\n[4/5] Validating data structure...', colors.blue);

  // Check for required top-level keys
  const requiredKeys = ['itinerary', 'images', 'price'];
  const missingKeys = requiredKeys.filter((key) => !(key in jsonData));

  if (missingKeys.length > 0) {
    log(`  ✗ Missing required keys: ${missingKeys.join(', ')}`, colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log(`FAIL: Missing required keys: ${missingKeys.join(', ')}`, colors.red);
    process.exit(1);
  }

  log('  ✓ All required keys present: itinerary, images, price', colors.green);

  // Validate itinerary is an object
  if (typeof jsonData.itinerary !== 'object' || jsonData.itinerary === null) {
    log('  ✗ "itinerary" is not an object', colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: "itinerary" must be an object', colors.red);
    process.exit(1);
  }

  log('  ✓ "itinerary" is an object', colors.green);

  // Validate images is an array
  if (!Array.isArray(jsonData.images)) {
    log('  ✗ "images" is not an array', colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: "images" must be an array', colors.red);
    process.exit(1);
  }

  log('  ✓ "images" is an array', colors.green);

  // Validate price is a number
  if (typeof jsonData.price !== 'number') {
    log('  ✗ "price" is not a number', colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: "price" must be a number', colors.red);
    process.exit(1);
  }

  log('  ✓ "price" is a number', colors.green);

  // Step 6: Assert specific data requirements
  log('\n[5/5] Validating data content...', colors.blue);

  // Assert images.length > 0
  if (jsonData.images.length === 0) {
    log('  ✗ "images" array is empty', colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: images array is empty', colors.red);
    process.exit(1);
  }

  log(`  ✓ "images" array contains ${jsonData.images.length} item(s)`, colors.green);

  // Assert price is an integer (in cents)
  if (!Number.isInteger(jsonData.price)) {
    log('  ✗ "price" is not an integer (must be in cents)', colors.red);
    cleanupOutputFile(outputPath);
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    log('FAIL: price must be an integer (in cents)', colors.red);
    process.exit(1);
  }

  const priceInDollars = (jsonData.price / 100).toFixed(2);
  log(`  ✓ "price" is an integer: ${jsonData.price} cents ($${priceInDollars})`, colors.green);

  // All validations passed!
  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  log('\n✓ All checks passed:', colors.green);
  log(`  • Output file created: ${outputPath}`, colors.green);
  log(`  • File size: ${fileSizeKB} KB`, colors.green);
  log(`  • Valid JSON structure`, colors.green);
  log(`  • itinerary: object with ${Object.keys(jsonData.itinerary).length} keys`, colors.green);
  log(`  • images: array with ${jsonData.images.length} items`, colors.green);
  log(`  • price: ${jsonData.price} cents ($${priceInDollars})`, colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log('  Phase 2 Scraper Validation: PASS', colors.green);
  log('='.repeat(60) + '\n', colors.bright);

  process.exit(0);
}

// Main execution
if (require.main === module) {
  const { url } = parseArgs();

  if (!url) {
    log('\n✗ Error: No URL provided', colors.red);
    log('\nUsage: node validation_scripts/validate_phase_2.cjs --url <ITRVL_URL>', colors.yellow);
    log('\nExample:', colors.yellow);
    log('  node validation_scripts/validate_phase_2.cjs --url "https://portal.itrvl.com/share?accessKey=ABC123&itineraryId=12345"\n', colors.cyan);
    process.exit(1);
  }

  validatePhase2(url).catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 2 Scraper Validation: FAIL', colors.red);
    process.exit(1);
  });
}

========================================
=== FILE: validation_scripts/validate_phase_3.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 3: Media Ingestion & Rehosting Pipeline - Validation Script
 *
 * This script validates that images were successfully uploaded to Payload CMS
 * by performing HTTP HEAD requests on a random sample of uploaded media.
 *
 * Usage: node validation_scripts/validate_phase_3.cjs
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Perform HTTP HEAD request to check if URL is accessible
async function checkUrlAccessibility(url) {
  try {
    const response = await axios.head(url, {
      timeout: 10000,
      validateStatus: (status) => status < 600, // Don't throw on any status
    });

    return {
      url,
      statusCode: response.status,
      success: response.status === 200,
    };
  } catch (error) {
    if (error.response) {
      return {
        url,
        statusCode: error.response.status,
        success: false,
      };
    }
    return {
      url,
      statusCode: null,
      success: false,
      error: error.message,
    };
  }
}

// Randomly select N items from array
function randomSample(array, n) {
  if (array.length <= n) {
    return array;
  }

  const shuffled = [...array].sort(() => 0.5 - Math.random());
  return shuffled.slice(0, n);
}

// Main validation function
async function validatePhase3() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 3: MEDIA VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  // Step 1: Load media mapping file
  log('\n[1/4] Loading media mapping file...', colors.blue);
  const mappingPath = path.join(process.cwd(), 'output', 'media-mapping.json');

  if (!fs.existsSync(mappingPath)) {
    log(`  ✗ Mapping file not found: ${mappingPath}`, colors.red);
    log('\nPhase 3 Media Validation: FAIL', colors.red);
    log('FAIL: media-mapping.json does not exist', colors.red);
    process.exit(1);
  }

  let mappingData;
  try {
    const fileContent = fs.readFileSync(mappingPath, 'utf8');
    mappingData = JSON.parse(fileContent);
    log(`  ✓ Loaded: ${mappingPath}`, colors.green);
  } catch (error) {
    log(`  ✗ Failed to parse JSON: ${error.message}`, colors.red);
    log('\nPhase 3 Media Validation: FAIL', colors.red);
    log('FAIL: Invalid JSON in media-mapping.json', colors.red);
    process.exit(1);
  }

  // Validate mapping structure
  if (!Array.isArray(mappingData)) {
    log('  ✗ Mapping data is not an array', colors.red);
    log('\nPhase 3 Media Validation: FAIL', colors.red);
    log('FAIL: media-mapping.json must be an array', colors.red);
    process.exit(1);
  }

  log(`  ✓ Found ${mappingData.length} entries in mapping`, colors.green);

  if (mappingData.length === 0) {
    log('  ⚠ No entries to validate (empty mapping)', colors.yellow);
    log('\nPhase 3 Media Validation: PASS (0/0 sample URLs checked)', colors.green);
    process.exit(0);
  }

  // Filter successful uploads only
  const successfulUploads = mappingData.filter(
    (entry) => entry.status === 'success' && entry.newS3Url
  );

  if (successfulUploads.length === 0) {
    log('  ✗ No successful uploads found in mapping', colors.red);
    log('\nPhase 3 Media Validation: FAIL', colors.red);
    log('FAIL: No successful uploads to validate', colors.red);
    process.exit(1);
  }

  log(`  ✓ Found ${successfulUploads.length} successful uploads`, colors.green);

  // Step 2: Select random sample
  log('\n[2/4] Selecting sample URLs to validate...', colors.blue);
  const sampleSize = Math.min(5, successfulUploads.length);
  const sampleEntries = randomSample(successfulUploads, sampleSize);

  log(`  ✓ Selected ${sampleEntries.length} URLs for validation`, colors.green);

  // Step 3: Validate each URL
  log('\n[3/4] Checking URL accessibility...', colors.blue);
  const results = [];

  for (let i = 0; i < sampleEntries.length; i++) {
    const entry = sampleEntries[i];
    const url = entry.newS3Url;

    log(`\n  [${i + 1}/${sampleEntries.length}] ${url}`, colors.cyan);

    const result = await checkUrlAccessibility(url);
    results.push(result);

    if (result.success) {
      log(`    ✓ HTTP ${result.statusCode} - OK`, colors.green);
    } else {
      if (result.statusCode) {
        log(`    ✗ HTTP ${result.statusCode} - Failed`, colors.red);
      } else {
        log(`    ✗ Request failed: ${result.error}`, colors.red);
      }
    }

    // Small delay between requests
    if (i < sampleEntries.length - 1) {
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
  }

  // Step 4: Analyze results
  log('\n[4/4] Analyzing results...', colors.blue);

  const successCount = results.filter((r) => r.success).length;
  const failCount = results.filter((r) => !r.success).length;

  log(`  → Successful checks: ${successCount}`, colors.cyan);
  log(`  → Failed checks: ${failCount}`, colors.cyan);

  // Check for failures
  const failedResults = results.filter((r) => !r.success);

  if (failedResults.length > 0) {
    log('\n  ✗ Failed URL checks:', colors.red);
    failedResults.forEach((result) => {
      if (result.statusCode) {
        log(`    • ${result.url} - HTTP ${result.statusCode}`, colors.red);
      } else {
        log(`    • ${result.url} - ${result.error}`, colors.red);
      }
    });

    log('\n' + '='.repeat(60), colors.bright);
    log('  Phase 3 Media Validation: FAIL', colors.red);
    log(`  ${failCount} out of ${sampleEntries.length} URLs failed`, colors.red);
    log('='.repeat(60) + '\n', colors.bright);
    process.exit(1);
  }

  // All checks passed!
  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  log('\n✓ All checks passed:', colors.green);
  log(`  • Mapping file: ${mappingPath}`, colors.green);
  log(`  • Total entries: ${mappingData.length}`, colors.green);
  log(`  • Successful uploads: ${successfulUploads.length}`, colors.green);
  log(`  • Sample size: ${sampleEntries.length}`, colors.green);
  log(`  • All sample URLs returned HTTP 200`, colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log(
    `  Phase 3 Media Validation: PASS (${successCount}/${sampleEntries.length} sample URLs checked)`,
    colors.green
  );
  log('='.repeat(60) + '\n', colors.bright);

  process.exit(0);
}

// Main execution
if (require.main === module) {
  validatePhase3().catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 3 Media Validation: FAIL', colors.red);
    process.exit(1);
  });
}

========================================
=== FILE: validation_scripts/validate_phase_4.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 4: AI-Driven Content Enhancement - Validation Script
 *
 * This script validates that content was successfully enhanced by Gemini AI
 * by comparing the byte lengths of original and enhanced descriptions.
 *
 * Usage: node validation_scripts/validate_phase_4.cjs
 */

const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Main validation function
async function validatePhase4() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 4: AI ENHANCEMENT VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  // Step 1: Load raw itinerary
  log('\n[1/5] Loading raw itinerary...', colors.blue);
  const rawPath = path.join(process.cwd(), 'output', 'raw-itinerary.json');

  if (!fs.existsSync(rawPath)) {
    log(`  ✗ Raw itinerary not found: ${rawPath}`, colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: raw-itinerary.json does not exist', colors.red);
    process.exit(1);
  }

  let rawData;
  try {
    const fileContent = fs.readFileSync(rawPath, 'utf8');
    rawData = JSON.parse(fileContent);
    log(`  ✓ Loaded: ${rawPath}`, colors.green);
  } catch (error) {
    log(`  ✗ Failed to parse raw JSON: ${error.message}`, colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: Invalid JSON in raw-itinerary.json', colors.red);
    process.exit(1);
  }

  // Step 2: Load enhanced itinerary
  log('\n[2/5] Loading enhanced itinerary...', colors.blue);
  const enhancedPath = path.join(process.cwd(), 'output', 'enhanced-itinerary.json');

  if (!fs.existsSync(enhancedPath)) {
    log(`  ✗ Enhanced itinerary not found: ${enhancedPath}`, colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: enhanced-itinerary.json does not exist', colors.red);
    process.exit(1);
  }

  let enhancedData;
  try {
    const fileContent = fs.readFileSync(enhancedPath, 'utf8');
    enhancedData = JSON.parse(fileContent);
    log(`  ✓ Loaded: ${enhancedPath}`, colors.green);

    const fileSize = (fs.statSync(enhancedPath).size / 1024).toFixed(2);
    log(`  → File size: ${fileSize} KB`, colors.cyan);
  } catch (error) {
    log(`  ✗ Failed to parse enhanced JSON: ${error.message}`, colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: Invalid JSON in enhanced-itinerary.json', colors.red);
    process.exit(1);
  }

  // Step 3: Extract segments
  log('\n[3/5] Extracting segments...', colors.blue);

  // Validate structure
  if (!rawData.itinerary?.itineraries?.[0]?.segments) {
    log('  ✗ Invalid raw itinerary structure', colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: Invalid itinerary structure in raw data', colors.red);
    process.exit(1);
  }

  if (!enhancedData.itinerary?.itineraries?.[0]?.segments) {
    log('  ✗ Invalid enhanced itinerary structure', colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: Invalid itinerary structure in enhanced data', colors.red);
    process.exit(1);
  }

  const rawSegments = rawData.itinerary.itineraries[0].segments;
  const enhancedSegments = enhancedData.itinerary.itineraries[0].segments;

  log(`  ✓ Found ${rawSegments.length} segments in raw data`, colors.green);
  log(`  ✓ Found ${enhancedSegments.length} segments in enhanced data`, colors.green);

  // Step 4: Find first segment with description
  log('\n[4/5] Comparing first segment with description...', colors.blue);

  let firstSegmentIndex = -1;
  let rawSegment = null;
  let enhancedSegment = null;

  for (let i = 0; i < rawSegments.length; i++) {
    if (rawSegments[i].description && rawSegments[i].description.trim().length > 0) {
      firstSegmentIndex = i;
      rawSegment = rawSegments[i];
      enhancedSegment = enhancedSegments[i];
      break;
    }
  }

  if (firstSegmentIndex === -1) {
    log('  ✗ No segments with descriptions found', colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: No segments with descriptions to validate', colors.red);
    process.exit(1);
  }

  const segmentName = rawSegment.title || rawSegment.name || `Segment ${firstSegmentIndex + 1}`;
  log(`  → Validating: ${segmentName}`, colors.cyan);

  // Check for description_enhanced field
  if (!enhancedSegment.description_enhanced) {
    log('  ✗ No description_enhanced field found', colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: description_enhanced field is missing', colors.red);
    process.exit(1);
  }

  log('  ✓ description_enhanced field exists', colors.green);

  // Step 5: Compare byte lengths
  log('\n[5/5] Comparing content lengths...', colors.blue);

  const originalDesc = rawSegment.description;
  const enhancedDesc = enhancedSegment.description_enhanced;

  const originalLength = Buffer.byteLength(originalDesc, 'utf8');
  const enhancedLength = Buffer.byteLength(enhancedDesc, 'utf8');

  log(`  → Original length: ${originalLength} bytes`, colors.cyan);
  log(`  → Enhanced length: ${enhancedLength} bytes`, colors.cyan);

  if (enhancedLength <= originalLength) {
    const diff = originalLength - enhancedLength;
    log(`  ✗ Enhanced content is shorter by ${diff} bytes`, colors.red);
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    log('FAIL: Enhanced content is not longer than original', colors.red);
    process.exit(1);
  }

  const growth = enhancedLength - originalLength;
  const growthPercent = ((growth / originalLength) * 100).toFixed(1);

  log(`  ✓ Enhanced content is longer by ${growth} bytes (+${growthPercent}%)`, colors.green);

  // Count all enhanced segments
  const enhancedCount = enhancedSegments.filter(s => s.description_enhanced).length;
  const withDescCount = rawSegments.filter(s => s.description && s.description.trim().length > 0).length;

  // All checks passed!
  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  log('\n✓ All checks passed:', colors.green);
  log(`  • Enhanced itinerary file exists and is valid JSON`, colors.green);
  log(`  • Validated segment: ${segmentName}`, colors.green);
  log(`  • Original description: ${originalLength} bytes`, colors.green);
  log(`  • Enhanced description: ${enhancedLength} bytes (+${growthPercent}%)`, colors.green);
  log(`  • Total segments enhanced: ${enhancedCount}/${withDescCount}`, colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log('  Phase 4 AI Enhancement: PASS (Content enhanced)', colors.green);
  log('='.repeat(60) + '\n', colors.bright);

  process.exit(0);
}

// Main execution
if (require.main === module) {
  validatePhase4().catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 4 AI Enhancement: FAIL', colors.red);
    process.exit(1);
  });
}

========================================
=== FILE: validation_scripts/validate_phase_5.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 5: Product Schema Generation & Internal Validation - Validation Script
 *
 * This script validates the generated schema.jsonld against the kiuli-product.schema.json
 * using the AJV JSON Schema validator. This is the internal validator that runs before
 * any external API calls.
 *
 * Usage: node validation_scripts/validate_phase_5.cjs
 */

const Ajv = require('ajv');
const addFormats = require('ajv-formats');
const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Format AJV validation errors in a readable way
function formatValidationErrors(errors) {
  if (!errors || errors.length === 0) {
    return [];
  }

  return errors.map((error) => {
    const path = error.instancePath || 'root';
    const message = error.message;
    const params = error.params;

    let detailedMessage = `  • Path: ${path}`;

    if (error.keyword === 'const') {
      detailedMessage += ` - must be "${params.allowedValue}"`;
    } else if (error.keyword === 'pattern') {
      detailedMessage += ` - ${message} (pattern: ${params.pattern})`;
    } else if (error.keyword === 'not') {
      detailedMessage += ` - must not match forbidden pattern`;
    } else {
      detailedMessage += ` - ${message}`;
    }

    if (params && Object.keys(params).length > 0) {
      detailedMessage += `\n    Params: ${JSON.stringify(params)}`;
    }

    return detailedMessage;
  });
}

// Main validation function
async function validatePhase5() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 5: INTERNAL SCHEMA VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  // Step 1: Load the JSON Schema
  log('\n[1/4] Loading Kiuli Product schema definition...', colors.blue);
  const schemaPath = path.join(process.cwd(), 'schemas', 'kiuli-product.schema.json');

  if (!fs.existsSync(schemaPath)) {
    log(`  ✗ Schema definition not found: ${schemaPath}`, colors.red);
    log('\nPhase 5 Internal Schema Validation: FAIL', colors.red);
    log('FAIL: Schema definition file missing', colors.red);
    process.exit(1);
  }

  let schemaDefinition;
  try {
    const fileContent = fs.readFileSync(schemaPath, 'utf8');
    schemaDefinition = JSON.parse(fileContent);
    log(`  ✓ Loaded: ${schemaPath}`, colors.green);
  } catch (error) {
    log(`  ✗ Failed to parse schema: ${error.message}`, colors.red);
    log('\nPhase 5 Internal Schema Validation: FAIL', colors.red);
    log('FAIL: Invalid schema definition', colors.red);
    process.exit(1);
  }

  // Step 2: Initialize AJV validator
  log('\n[2/4] Initializing AJV validator...', colors.blue);

  try {
    const ajv = new Ajv({
      allErrors: true,
      verbose: true,
      strict: false,
    });

    // Add format validation (uri, email, etc.)
    addFormats(ajv);

    const validate = ajv.compile(schemaDefinition);
    log('  ✓ AJV validator initialized', colors.green);
    log('  ✓ Schema compiled successfully', colors.green);

    // Step 3: Load the generated schema.jsonld
    log('\n[3/4] Loading generated schema.jsonld...', colors.blue);
    const schemaJsonldPath = path.join(process.cwd(), 'output', 'schema.jsonld');

    if (!fs.existsSync(schemaJsonldPath)) {
      log(`  ✗ schema.jsonld not found: ${schemaJsonldPath}`, colors.red);
      log('\nPhase 5 Internal Schema Validation: FAIL', colors.red);
      log('FAIL: schema.jsonld does not exist', colors.red);
      process.exit(1);
    }

    let schemaData;
    try {
      const fileContent = fs.readFileSync(schemaJsonldPath, 'utf8');
      schemaData = JSON.parse(fileContent);
      const fileSize = (fs.statSync(schemaJsonldPath).size / 1024).toFixed(2);
      log(`  ✓ Loaded: ${schemaJsonldPath}`, colors.green);
      log(`  → File size: ${fileSize} KB`, colors.cyan);
    } catch (error) {
      log(`  ✗ Failed to parse schema.jsonld: ${error.message}`, colors.red);
      log('\nPhase 5 Internal Schema Validation: FAIL', colors.red);
      log('FAIL: Invalid JSON in schema.jsonld', colors.red);
      process.exit(1);
    }

    // Step 4: Validate the schema
    log('\n[4/4] Validating schema.jsonld against Kiuli Product schema...', colors.blue);

    const valid = validate(schemaData);

    if (!valid) {
      log('  ✗ Validation failed', colors.red);
      log('\n  Validation Errors:', colors.red);

      const formattedErrors = formatValidationErrors(validate.errors);
      formattedErrors.forEach((error) => {
        log(error, colors.red);
      });

      // Check for specific critical errors
      const errorMessages = validate.errors.map(e => `${e.instancePath} ${e.message}`);

      log('\n' + '='.repeat(60), colors.bright);
      log('  Phase 5 Internal Schema Validation: FAIL', colors.red);
      log('='.repeat(60), colors.bright);

      log('\n  Critical Validation Failures:', colors.red);
      validate.errors.forEach((error) => {
        log(`  FAIL: ${error.instancePath || 'data'}${error.instancePath ? '' : '.'} ${error.message}`, colors.red);
      });

      log('', colors.reset);
      process.exit(1);
    }

    // All validations passed!
    log('  ✓ All validations passed', colors.green);

    log('\n' + '='.repeat(60), colors.bright);
    log('  VALIDATION SUMMARY', colors.bright);
    log('='.repeat(60), colors.bright);

    log('\n✓ Schema structure validated:', colors.green);
    log(`  • @context: ${schemaData['@context']}`, colors.green);
    log(`  • @type: ${schemaData['@type']}`, colors.green);
    log(`  • name: "${schemaData.name}"`, colors.green);
    log(`  • description: ${schemaData.description.length} characters`, colors.green);
    log(`  • images: ${schemaData.image.length} rehosted URLs`, colors.green);
    log(`  • brand: ${schemaData.brand.name}`, colors.green);
    log(`  • sku: ${schemaData.sku}`, colors.green);
    log(`  • offers.price: $${schemaData.offers.price} ${schemaData.offers.priceCurrency}`, colors.green);
    log(`  • offers.availability: ${schemaData.offers.availability}`, colors.green);

    // Check for forbidden domains
    const hasForbiddenDomains = schemaData.image.some(url => url.includes('itrvl.imgix.net'));
    if (!hasForbiddenDomains) {
      log(`  • ✓ No forbidden domains (itrvl.imgix.net) detected`, colors.green);
    }

    log('\n' + '='.repeat(60), colors.bright);
    log('  Phase 5 Internal Schema Validation: PASS', colors.green);
    log('='.repeat(60) + '\n', colors.bright);

    process.exit(0);
  } catch (error) {
    log(`  ✗ AJV initialization failed: ${error.message}`, colors.red);
    log('\nPhase 5 Internal Schema Validation: FAIL', colors.red);
    log('FAIL: Validator initialization error', colors.red);
    process.exit(1);
  }
}

// Main execution
if (require.main === module) {
  validatePhase5().catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 5 Internal Schema Validation: FAIL', colors.red);
    process.exit(1);
  });
}

========================================
=== FILE: validation_scripts/validate_phase_6.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 6: FAQ Content Formatting - Validation Script
 *
 * This script validates that the FAQ HTML file was generated correctly by checking
 * for the presence of <details> and <summary> tags.
 *
 * Usage: node validation_scripts/validate_phase_6.cjs
 */

const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Count occurrences of a tag in HTML content
function countTags(content, tagName) {
  const regex = new RegExp(`<${tagName}[^>]*>`, 'gi');
  const matches = content.match(regex);
  return matches ? matches.length : 0;
}

// Main validation function
async function validatePhase6() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 6: FAQ VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  // Step 1: Check if FAQ file exists
  log('\n[1/3] Checking for FAQ HTML file...', colors.blue);
  const faqPath = path.join(process.cwd(), 'output', 'faq.html');

  if (!fs.existsSync(faqPath)) {
    log(`  ✗ FAQ file not found: ${faqPath}`, colors.red);
    log('\nPhase 6 FAQ Validation: FAIL', colors.red);
    log('FAIL: faq.html does not exist', colors.red);
    process.exit(1);
  }

  log(`  ✓ Found: ${faqPath}`, colors.green);

  // Step 2: Read and validate file content
  log('\n[2/3] Reading and analyzing FAQ content...', colors.blue);

  let content;
  try {
    content = fs.readFileSync(faqPath, 'utf8');
    const fileSize = (fs.statSync(faqPath).size / 1024).toFixed(2);
    log(`  ✓ Loaded: ${faqPath}`, colors.green);
    log(`  → File size: ${fileSize} KB`, colors.cyan);
  } catch (error) {
    log(`  ✗ Failed to read FAQ file: ${error.message}`, colors.red);
    log('\nPhase 6 FAQ Validation: FAIL', colors.red);
    log('FAIL: Could not read faq.html', colors.red);
    process.exit(1);
  }

  // Check if file is empty
  if (!content || content.trim().length === 0) {
    log('  ✗ FAQ file is empty', colors.red);
    log('\nPhase 6 FAQ Validation: FAIL', colors.red);
    log('FAIL: faq.html is empty', colors.red);
    process.exit(1);
  }

  log(`  ✓ Content length: ${content.length} characters`, colors.green);

  // Step 3: Count tags and validate structure
  log('\n[3/3] Validating HTML structure...', colors.blue);

  const detailsCount = countTags(content, 'details');
  const summaryCount = countTags(content, 'summary');

  log(`  → Found <details> tags: ${detailsCount}`, colors.cyan);
  log(`  → Found <summary> tags: ${summaryCount}`, colors.cyan);

  // Validate tag counts
  if (detailsCount === 0) {
    log('  ✗ No <details> tags found', colors.red);
    log('\nPhase 6 FAQ Validation: FAIL', colors.red);
    log('FAIL: No <details> tags found in faq.html', colors.red);
    process.exit(1);
  }

  if (summaryCount === 0) {
    log('  ✗ No <summary> tags found', colors.red);
    log('\nPhase 6 FAQ Validation: FAIL', colors.red);
    log('FAIL: No <summary> tags found in faq.html', colors.red);
    process.exit(1);
  }

  // Check if counts match (each <details> should have a <summary>)
  if (detailsCount !== summaryCount) {
    log(`  ⚠ Warning: <details> count (${detailsCount}) does not match <summary> count (${summaryCount})`, colors.yellow);
  }

  log('  ✓ Valid HTML structure detected', colors.green);

  // All validations passed!
  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  log('\n✓ FAQ structure validated:', colors.green);
  log(`  • File exists: ${faqPath}`, colors.green);
  log(`  • Content length: ${content.length} characters`, colors.green);
  log(`  • <details> tags: ${detailsCount}`, colors.green);
  log(`  • <summary> tags: ${summaryCount}`, colors.green);
  log(`  • Q&A pairs: ${Math.min(detailsCount, summaryCount)}`, colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log(`  Phase 6 FAQ Validation: PASS (Found ${detailsCount} details tags, ${summaryCount} summary tags)`, colors.green);
  log('='.repeat(60) + '\n', colors.bright);

  process.exit(0);
}

// Main execution
if (require.main === module) {
  validatePhase6().catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 6 FAQ Validation: FAIL', colors.red);
    process.exit(1);
  });
}

========================================
=== FILE: validation_scripts/validate_phase_7.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 7: Payload CMS Ingestion - Validation Script
 *
 * This script validates that the draft itinerary entry was created correctly
 * in Payload CMS by fetching it via the API and checking its status fields.
 *
 * Usage: node validation_scripts/validate_phase_7.cjs
 */

// Load environment variables
require('dotenv').config({ path: '.env.local' });

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Validate environment variables
function validateEnv() {
  const apiUrl = process.env.PAYLOAD_API_URL;
  const apiKey = process.env.PAYLOAD_API_KEY;

  if (!apiUrl) {
    throw new Error('PAYLOAD_API_URL environment variable not set');
  }

  if (!apiKey) {
    throw new Error('PAYLOAD_API_KEY environment variable not set');
  }

  return { apiUrl, apiKey };
}

// Main validation function
async function validatePhase7() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 7: PAYLOAD INGESTION VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  // Step 1: Validate environment
  log('\n[1/4] Validating environment...', colors.blue);
  let apiUrl, apiKey;
  try {
    ({ apiUrl, apiKey } = validateEnv());
    log(`  ✓ PAYLOAD_API_URL: ${apiUrl}`, colors.green);
    log(`  ✓ PAYLOAD_API_KEY: ${apiKey.substring(0, 8)}...`, colors.green);
  } catch (error) {
    log(`  ✗ ${error.message}`, colors.red);
    log('\nPhase 7 Payload Ingestion: FAIL', colors.red);
    log('FAIL: Environment validation error', colors.red);
    process.exit(1);
  }

  // Step 2: Read entry ID from file
  log('\n[2/4] Reading entry ID from file...', colors.blue);
  const idFilePath = path.join(process.cwd(), 'output', 'payload_id.txt');

  if (!fs.existsSync(idFilePath)) {
    log(`  ✗ ID file not found: ${idFilePath}`, colors.red);
    log('\nPhase 7 Payload Ingestion: FAIL', colors.red);
    log('FAIL: payload_id.txt does not exist', colors.red);
    process.exit(1);
  }

  let entryId;
  try {
    entryId = fs.readFileSync(idFilePath, 'utf8').trim();
    log(`  ✓ Entry ID: ${entryId}`, colors.green);
  } catch (error) {
    log(`  ✗ Failed to read ID file: ${error.message}`, colors.red);
    log('\nPhase 7 Payload Ingestion: FAIL', colors.red);
    log('FAIL: Could not read payload_id.txt', colors.red);
    process.exit(1);
  }

  // Step 3: Fetch entry from Payload API
  log('\n[3/4] Fetching entry from Payload API...', colors.blue);

  let entry;
  try {
    const response = await axios.get(
      `${apiUrl}/api/itineraries/${entryId}`,
      {
        headers: {
          'Authorization': `users API-Key ${apiKey}`,
          'Content-Type': 'application/json',
        },
        timeout: 20000, // 20 second timeout
      }
    );

    entry = response.data;

    if (!entry || !entry.id) {
      throw new Error('Invalid response from Payload API - no entry returned');
    }

    log(`  ✓ Entry fetched successfully`, colors.green);
    log(`  → ID: ${entry.id}`, colors.cyan);
    log(`  → Title: ${entry.title}`, colors.cyan);
  } catch (error) {
    log(`  ✗ Failed to fetch entry: ${error.message}`, colors.red);

    if (error.response) {
      log(`  → Status code: ${error.response.status}`, colors.red);

      if (error.response.status === 404) {
        log(`  → Entry not found with ID: ${entryId}`, colors.red);
      }
    }

    log('\nPhase 7 Payload Ingestion: FAIL', colors.red);
    log('FAIL: Entry not found or could not be fetched', colors.red);
    process.exit(1);
  }

  // Step 4: Validate entry fields
  log('\n[4/4] Validating entry fields...', colors.blue);

  let validationErrors = [];

  // Check if entry is null
  if (!entry) {
    validationErrors.push('Entry is null');
  }

  // Check status field
  const status = entry._status;
  if (status !== 'draft') {
    validationErrors.push(`Status is "${status}", expected "draft"`);
  } else {
    log(`  ✓ Status: ${status}`, colors.green);
  }

  // Check googleInspectionStatus field
  const googleStatus = entry.googleInspectionStatus;
  if (googleStatus !== 'pending') {
    validationErrors.push(`googleInspectionStatus is "${googleStatus}", expected "pending"`);
  } else {
    log(`  ✓ Google Inspection Status: ${googleStatus}`, colors.green);
  }

  // Check schemaStatus field (should be "pass" from Phase 5)
  const schemaStatus = entry.schemaStatus;
  if (schemaStatus !== 'pass') {
    log(`  ⚠ schemaStatus is "${schemaStatus}", expected "pass"`, colors.yellow);
  } else {
    log(`  ✓ Schema Status: ${schemaStatus}`, colors.green);
  }

  // If there are validation errors, fail
  if (validationErrors.length > 0) {
    log('\n  ✗ Validation failed:', colors.red);
    validationErrors.forEach(error => {
      log(`    • ${error}`, colors.red);
    });

    log('\n' + '='.repeat(60), colors.bright);
    log('  Phase 7 Payload Ingestion: FAIL', colors.red);
    log('='.repeat(60), colors.bright);

    log('\n  Critical Validation Failures:', colors.red);
    validationErrors.forEach(error => {
      log(`  FAIL: ${error}`, colors.red);
    });

    log('', colors.reset);
    process.exit(1);
  }

  // All validations passed!
  log('  ✓ All validations passed', colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  log('\n✓ Payload entry validated:', colors.green);
  log(`  • Entry ID: ${entry.id}`, colors.green);
  log(`  • Title: ${entry.title}`, colors.green);
  log(`  • Status: ${entry._status}`, colors.green);
  log(`  • Schema Status: ${entry.schemaStatus}`, colors.green);
  log(`  • Google Inspection Status: ${entry.googleInspectionStatus}`, colors.green);
  log(`  • Build Timestamp: ${entry.buildTimestamp}`, colors.green);
  log(`  • Images: ${entry.images?.length || 0} linked`, colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log(`  Phase 7 Payload Ingestion: PASS (Draft created with ID: ${entry.id})`, colors.green);
  log('='.repeat(60) + '\n', colors.bright);

  process.exit(0);
}

// Main execution
if (require.main === module) {
  validatePhase7().catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 7 Payload Ingestion: FAIL', colors.red);
    process.exit(1);
  });
}

========================================
=== FILE: validation_scripts/validate_phase_8.cjs ===
========================================
#!/usr/bin/env node

/**
 * Phase 8: Vercel Function Deployment - Validation Script
 *
 * This script validates that the API route correctly executes the full pipeline
 * by making a POST request to the local development server and verifying that
 * a draft entry was created in Payload CMS.
 *
 * Usage: node validation_scripts/validate_phase_8.cjs --url <TEST_URL>
 */

// Load environment variables
require('dotenv').config({ path: '.env.local' });

const axios = require('axios');
const fs = require('fs');
const path = require('path');

// ANSI color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

// Helper function to log with color
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const urlIndex = args.indexOf('--url');

  if (urlIndex === -1 || urlIndex === args.length - 1) {
    throw new Error('Missing required argument: --url <TEST_URL>');
  }

  return {
    testUrl: args[urlIndex + 1],
  };
}

// Validate environment variables
function validateEnv() {
  const apiUrl = process.env.PAYLOAD_API_URL;
  const apiKey = process.env.PAYLOAD_API_KEY;

  if (!apiUrl) {
    throw new Error('PAYLOAD_API_URL environment variable not set');
  }

  if (!apiKey) {
    throw new Error('PAYLOAD_API_KEY environment variable not set');
  }

  return { apiUrl, apiKey };
}

// Main validation function
async function validatePhase8() {
  log('\n' + '='.repeat(60), colors.bright);
  log('  PHASE 8: VERCEL FUNCTION VALIDATION', colors.bright);
  log('='.repeat(60), colors.bright);

  // Step 1: Parse arguments
  log('\n[1/6] Parsing command line arguments...', colors.blue);
  let testUrl;
  try {
    ({ testUrl } = parseArgs());
    log(`  ✓ Test URL: ${testUrl}`, colors.green);
  } catch (error) {
    log(`  ✗ ${error.message}`, colors.red);
    log('\nUsage: node validation_scripts/validate_phase_8.cjs --url <TEST_URL>', colors.yellow);
    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    process.exit(1);
  }

  // Step 2: Validate environment
  log('\n[2/6] Validating environment...', colors.blue);
  let apiUrl, apiKey;
  try {
    ({ apiUrl, apiKey } = validateEnv());
    log(`  ✓ PAYLOAD_API_URL: ${apiUrl}`, colors.green);
    log(`  ✓ PAYLOAD_API_KEY: ${apiKey.substring(0, 8)}...`, colors.green);
  } catch (error) {
    log(`  ✗ ${error.message}`, colors.red);
    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    log('FAIL: Environment validation error', colors.red);
    process.exit(1);
  }

  // Step 3: Make POST request to API route
  log('\n[3/6] Invoking API route /api/scrape-itinerary...', colors.blue);
  log(`  → URL: http://localhost:3000/api/scrape-itinerary`, colors.cyan);
  log(`  → Test itinerary: ${testUrl}`, colors.cyan);

  const startTime = Date.now();
  let apiResponse;

  try {
    apiResponse = await axios.post(
      'http://localhost:3000/api/scrape-itinerary',
      { itrvlUrl: testUrl },
      {
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 300000, // 5 minute timeout
      }
    );

    const duration = ((Date.now() - startTime) / 1000).toFixed(2);

    log(`  ✓ API route completed in ${duration}s`, colors.green);
    log(`  → Response status: ${apiResponse.status}`, colors.cyan);

    if (apiResponse.data) {
      log(`  → Success: ${apiResponse.data.success}`, colors.cyan);
      if (apiResponse.data.payloadId) {
        log(`  → Payload ID: ${apiResponse.data.payloadId}`, colors.cyan);
      }
      if (apiResponse.data.timings) {
        log(`\n  Performance Breakdown:`, colors.cyan);
        log(`  • Phase 2 (Scrape) completed in: ${apiResponse.data.timings.phase2}s`, colors.cyan);
        log(`  • Phase 3 (Media Rehost) completed in: ${apiResponse.data.timings.phase3}s`, colors.cyan);
        log(`  • Phase 4 (AI Enhance) completed in: ${apiResponse.data.timings.phase4}s`, colors.cyan);
        log(`  • Phase 5-7 (Processing/Ingest) completed in: ${apiResponse.data.timings.phase567}s`, colors.cyan);
        log(`  • Total Pipeline completed in: ${apiResponse.data.duration}s`, colors.cyan);
      }
      if (apiResponse.data.error) {
        log(`  → Error: ${apiResponse.data.error}`, colors.yellow);
      }
    }
  } catch (error) {
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);

    log(`  ✗ API route failed after ${duration}s`, colors.red);

    if (error.response) {
      log(`  → Status code: ${error.response.status}`, colors.red);
      log(`  → Error: ${JSON.stringify(error.response.data, null, 2)}`, colors.red);
    } else if (error.code === 'ECONNREFUSED') {
      log(`  → Error: Cannot connect to server at http://localhost:3000`, colors.red);
      log(`  → Make sure the dev server is running (npm run dev)`, colors.yellow);
    } else {
      log(`  → Error: ${error.message}`, colors.red);
    }

    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    log('FAIL: API route invocation failed', colors.red);
    process.exit(1);
  }

  // Step 4: Read entry ID from file
  log('\n[4/6] Reading entry ID from file...', colors.blue);
  const idFilePath = path.join(process.cwd(), 'output', 'payload_id.txt');

  if (!fs.existsSync(idFilePath)) {
    log(`  ✗ ID file not found: ${idFilePath}`, colors.red);
    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    log('FAIL: payload_id.txt does not exist', colors.red);
    process.exit(1);
  }

  let entryId;
  try {
    entryId = fs.readFileSync(idFilePath, 'utf8').trim();
    log(`  ✓ Entry ID: ${entryId}`, colors.green);
  } catch (error) {
    log(`  ✗ Failed to read ID file: ${error.message}`, colors.red);
    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    log('FAIL: Could not read payload_id.txt', colors.red);
    process.exit(1);
  }

  // Step 5: Fetch entry from Payload API
  log('\n[5/6] Fetching entry from Payload API...', colors.blue);

  let entry;
  try {
    const response = await axios.get(
      `${apiUrl}/api/itineraries/${entryId}`,
      {
        headers: {
          'Authorization': `users API-Key ${apiKey}`,
          'Content-Type': 'application/json',
        },
        timeout: 20000,
      }
    );

    entry = response.data;

    if (!entry || !entry.id) {
      throw new Error('Invalid response from Payload API - no entry returned');
    }

    log(`  ✓ Entry fetched successfully`, colors.green);
    log(`  → ID: ${entry.id}`, colors.cyan);
    log(`  → Title: ${entry.title}`, colors.cyan);
  } catch (error) {
    log(`  ✗ Failed to fetch entry: ${error.message}`, colors.red);

    if (error.response) {
      log(`  → Status code: ${error.response.status}`, colors.red);

      if (error.response.status === 404) {
        log(`  → Entry not found with ID: ${entryId}`, colors.red);
      }
    }

    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    log('FAIL: Entry not found or could not be fetched', colors.red);
    process.exit(1);
  }

  // Step 6: Validate entry fields
  log('\n[6/6] Validating entry fields...', colors.blue);

  let validationErrors = [];

  // Check if entry is null
  if (!entry) {
    validationErrors.push('Entry is null');
  }

  // Check status field
  const status = entry._status;
  if (status !== 'draft') {
    validationErrors.push(`Status is "${status}", expected "draft"`);
  } else {
    log(`  ✓ Status: ${status}`, colors.green);
  }

  // Check googleInspectionStatus field
  const googleStatus = entry.googleInspectionStatus;
  if (googleStatus !== 'pending') {
    validationErrors.push(`googleInspectionStatus is "${googleStatus}", expected "pending"`);
  } else {
    log(`  ✓ Google Inspection Status: ${googleStatus}`, colors.green);
  }

  // Check schemaStatus field (should be "pass" or "fail")
  const schemaStatus = entry.schemaStatus;
  if (schemaStatus !== 'pass' && schemaStatus !== 'fail') {
    log(`  ⚠ schemaStatus is "${schemaStatus}", expected "pass" or "fail"`, colors.yellow);
  } else {
    log(`  ✓ Schema Status: ${schemaStatus}`, colors.green);
  }

  // If there are validation errors, fail
  if (validationErrors.length > 0) {
    log('\n  ✗ Validation failed:', colors.red);
    validationErrors.forEach(error => {
      log(`    • ${error}`, colors.red);
    });

    log('\n' + '='.repeat(60), colors.bright);
    log('  Phase 8 Vercel Function Validation: FAIL', colors.red);
    log('='.repeat(60), colors.bright);

    log('\n  Critical Validation Failures:', colors.red);
    validationErrors.forEach(error => {
      log(`  FAIL: ${error}`, colors.red);
    });

    log('', colors.reset);
    process.exit(1);
  }

  // All validations passed!
  log('  ✓ All validations passed', colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log('  VALIDATION SUMMARY', colors.bright);
  log('='.repeat(60), colors.bright);

  log('\n✓ API route and Payload entry validated:', colors.green);
  log(`  • Entry ID: ${entry.id}`, colors.green);
  log(`  • Title: ${entry.title}`, colors.green);
  log(`  • Status: ${entry._status}`, colors.green);
  log(`  • Schema Status: ${entry.schemaStatus}`, colors.green);
  log(`  • Google Inspection Status: ${entry.googleInspectionStatus}`, colors.green);
  log(`  • Build Timestamp: ${entry.buildTimestamp}`, colors.green);
  log(`  • Images: ${entry.images?.length || 0} linked`, colors.green);

  log('\n' + '='.repeat(60), colors.bright);
  log(`  Phase 8 Vercel Function Validation: PASS (Local invocation successful, draft created)`, colors.green);
  log('='.repeat(60) + '\n', colors.bright);

  process.exit(0);
}

// Main execution
if (require.main === module) {
  validatePhase8().catch((error) => {
    log(`\n✗ Fatal error: ${error.message}`, colors.red);
    if (error.stack) {
      log(`\nStack trace:\n${error.stack}`, colors.red);
    }
    log('\nPhase 8 Vercel Function Validation: FAIL', colors.red);
    process.exit(1);
  });
}
